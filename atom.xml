<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-17T13:31:09.114Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>currying</title>
    <link href="http://yoursite.com/2018/04/17/currying-1/"/>
    <id>http://yoursite.com/2018/04/17/currying-1/</id>
    <published>2018-04-17T13:31:09.000Z</published>
    <updated>2018-04-17T13:31:09.114Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS函数柯里化和偏函数</title>
    <link href="http://yoursite.com/2018/03/06/currying/"/>
    <id>http://yoursite.com/2018/03/06/currying/</id>
    <published>2018-03-06T11:13:59.000Z</published>
    <updated>2018-04-17T13:14:46.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数柯里化的定义"><a href="#函数柯里化的定义" class="headerlink" title="函数柯里化的定义"></a>函数柯里化的定义</h2><p><strong>官方的定义</strong></p><p>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。</p><a id="more"></a><p><strong>直观的定义</strong></p><p>Currying即传递函数的一部分参数来调用它，然后让它返回一个函数来处理剩下的那部分参数</p><p><strong>代码展现</strong><br>需求：编写一个函数来实现求3个数字的乘积</p><p>正常函数实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acc</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*y*z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(acc(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure></p><p>柯里化函数实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acc</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">z</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x*y*z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> accTwo = acc(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> accTwoAndThree = accTwo(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> accThreeAndFour = accTwoAndThree(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(accThreeAndFour); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>在以上代码里，定义了一个acc函数，它只接受一个参数，然后返回了一个新的函数。第一次调用之后，由于闭包，记住了第一次函数的参数，然后通过第二次调用，又记住了第二个函数的参数，并且返回了另外一个全新的函数，最终在第三次调用是返回了之前记住的参数与当前参数的乘积；函数柯里化之后，看上去使得函数变得更加的复杂了，下面通过es6的箭头函数对上面的函数进行一个简单的改造；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> acc = <span class="function"><span class="params">x</span> =&gt;</span> y =&gt; <span class="function"><span class="params">z</span> =&gt;</span> x*y*z;</span><br></pre></td></tr></table></figure><p>简洁了许多有木有</p><p>通过以上代码的比对，我们发现最终算出的结果都是一样的，只是实现的过程不同而已；这也就好比一口气吃成胖子和慢慢吃成胖子是一个原理</p><h2 id="偏函数（partial）"><a href="#偏函数（partial）" class="headerlink" title="偏函数（partial）"></a>偏函数（partial）</h2><p>还是以上的需求，咱们用偏函数来实现对它的改造</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acc</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*y*z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, ...presetArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">partiallyApplied</span>(<span class="params">...laterArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn(...presetArgs, ...laterArgs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> accPartial = partial(acc, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(accPartial(<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>通过以上代码我们可以看到，我们新增了一个偏函数partial来接收fn函数作为一个形参和一个presetArgs数组来收集传入的实参，保存起来供之后来调用；然后，return出了一个partiallyApplied函数，此函数中拥有一个laterArgs数组参数来接受所有的实参。</p><h2 id="柯里化的实现-来自lodash"><a href="#柯里化的实现-来自lodash" class="headerlink" title="柯里化的实现(来自lodash)"></a>柯里化的实现(来自lodash)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span>  _argLen = fn.length</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">act</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            _args = _args.concat([].slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">            <span class="keyword">if</span>(_args.length === _argLen) &#123;</span><br><span class="line">                <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, _args)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">arguments</span>.callee</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(_args.length === _argLen) &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, _args)</span><br><span class="line">        &#125;</span><br><span class="line">        act.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.toString()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> act</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用柯利化求上例中乘积</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acc</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*y*z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = curry(acc);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><h2 id="反柯里化"><a href="#反柯里化" class="headerlink" title="反柯里化"></a>反柯里化</h2><p>物极必反，有时，得不到的永远在骚动，所以，为了以防万一，在拿到一个柯里化函数后，我们也要具备将之变回柯里化之前的函数的能力</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uncurrying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = fn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">      ret = ret(args[i]); <span class="comment">// 反复调用currying版本的函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回结果</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acc</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*y*z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> curryAcc = curry(acc);</span><br><span class="line"><span class="keyword">var</span> uncurryingAcc = uncurrying(curryAcc);</span><br><span class="line"><span class="built_in">console</span>.log(uncurryingAcc(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><h2 id="柯里化或偏函数总结"><a href="#柯里化或偏函数总结" class="headerlink" title="柯里化或偏函数总结"></a>柯里化或偏函数总结</h2><p>通过以上代码的对比和分析，可得出以下几点结论</p><blockquote><ul><li>偏函数应用是找一个函数，固定其中的几个参数值，从而得到一个新的函数。</li><li>函数柯里化是一种使用匿名单参数函数来实现多参数函数的方法。</li><li>当函数只有一个形参时，函数柯里化容易组合这些实参，它的职责比较单一</li><li>偏函数和柯里化函数不需要预先确定所有实参</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数柯里化的定义&quot;&gt;&lt;a href=&quot;#函数柯里化的定义&quot; class=&quot;headerlink&quot; title=&quot;函数柯里化的定义&quot;&gt;&lt;/a&gt;函数柯里化的定义&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;官方的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
</feed>
